/*
  One-time data migration from SQLite (file:./prisma/dev.db) to PostgreSQL (DATABASE_URL)
  Usage:
    1) Generate a dedicated SQLite Prisma Client:
       npx prisma generate --schema prisma/sqlite.schema.prisma
    2) Ensure .env has DATABASE_URL pointing to your Postgres (e.g., Neon) DB
    3) Ensure your prisma/schema.prisma matches the target schema (provider = "postgresql")
    4) Run: npm run migrate:sqlite-to-postgres
*/

const { PrismaClient: PgClient } = require("@prisma/client");
// This client is generated by: npx prisma generate --schema prisma/sqlite.schema.prisma
const { PrismaClient: SqliteClient } = require("@prisma/client-sqlite");

async function main() {
  // Source (SQLite) and Target (Postgres) clients
  const sqlite = new SqliteClient();
  const pg = new PgClient(); // uses DATABASE_URL from env

  try {
    console.log("Reading data from SQLite (./prisma/dev.db)...");

    // Read in dependency-safe order
    const users = await sqlite.user.findMany();
    const accounts = await sqlite.account.findMany();
    const sessions = await sqlite.session.findMany();
    const verificationTokens = await sqlite.verificationToken.findMany();

    const categories = await sqlite.category.findMany();
    const tags = await sqlite.tag.findMany();

    const posts = await sqlite.post.findMany();
    const postImages = await sqlite.postImage.findMany();
    const postCategories = await sqlite.postCategory.findMany();
    const postTags = await sqlite.postTag.findMany();

    const comments = await sqlite.comment.findMany();
    const subscriptions = await sqlite.subscription.findMany();

    console.log("Inserting into PostgreSQL (DATABASE_URL)...");

    // Upsert helpers preserve IDs
    const upsertMany = async (rows, model, keyFields) => {
      for (const row of rows) {
        const where = {};
        for (const k of keyFields) where[k] = row[k];
        await pg[model].upsert({
          where,
          update: row,
          create: row,
        });
      }
    };

    // Users
    await upsertMany(users, "user", ["id"]);
    console.log(`Users: ${users.length}`);

    // Accounts
    for (const a of accounts) {
      await pg.account.upsert({
        where: { provider_providerAccountId: { provider: a.provider, providerAccountId: a.providerAccountId } },
        update: a,
        create: a,
      });
    }
    console.log(`Accounts: ${accounts.length}`);

    // Sessions
    await upsertMany(sessions, "session", ["id"]);
    console.log(`Sessions: ${sessions.length}`);

    // VerificationTokens (composite unique)
    for (const vt of verificationTokens) {
      await pg.verificationToken.upsert({
        where: { identifier_token: { identifier: vt.identifier, token: vt.token } },
        update: vt,
        create: vt,
      });
    }
    console.log(`VerificationTokens: ${verificationTokens.length}`);

    // Taxonomies
    await upsertMany(categories, "category", ["id"]);
    console.log(`Categories: ${categories.length}`);

    await upsertMany(tags, "tag", ["id"]);
    console.log(`Tags: ${tags.length}`);

    // Posts
    await upsertMany(posts, "post", ["id"]);
    console.log(`Posts: ${posts.length}`);

    // Post images
    await upsertMany(postImages, "postImage", ["id"]);
    console.log(`PostImages: ${postImages.length}`);

    // Join tables
    // PostCategory (composite id)
    for (const pc of postCategories) {
      await pg.postCategory.upsert({
        where: { postId_categoryId: { postId: pc.postId, categoryId: pc.categoryId } },
        update: pc,
        create: pc,
      });
    }
    console.log(`PostCategories: ${postCategories.length}`);

    // PostTag (composite id)
    for (const pt of postTags) {
      await pg.postTag.upsert({
        where: { postId_tagId: { postId: pt.postId, tagId: pt.tagId } },
        update: pt,
        create: pt,
      });
    }
    console.log(`PostTags: ${postTags.length}`);

    // Comments
    await upsertMany(comments, "comment", ["id"]);
    console.log(`Comments: ${comments.length}`);

    // Subscriptions
    await upsertMany(subscriptions, "subscription", ["id"]);
    console.log(`Subscriptions: ${subscriptions.length}`);

    console.log("Done. Data migrated from SQLite to PostgreSQL.");
  } finally {
    await Promise.allSettled([sqlite.$disconnect(), pg.$disconnect()]);
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
